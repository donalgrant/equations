#!/usr/bin/env perl6

use v6;
use Test;

my $lib;

BEGIN { $lib=q{/Users/imel/gitdev/donalgrant/equations/lib} }

use lib $lib;
use-ok 'Board';
use Board;

my @board_methods=qw<new U R P F G clear_solutions save_solution required permitted forbidden unused goal
		     available display move_to_required move_to_permitted move_to_forbidden move_to_goal
		     install_goal solution_list req_num_tuples req_ops_tuples goal_options
		     calculate_solutions>;

can-ok( Board.new(''), $_ ) for @board_methods;

my $cube_list=q{1 2 2 3 - +};

isa-ok(Board.new($cube_list.join('')),     'Board', "Board from String");
isa-ok(Board.new($cube_list.join(' ')),    'Board', "Board with spaces");   # ignore spaces
isa-ok(Board.new([$cube_list]),            'Board', "Board from Array");
isa-ok(Board.new($cube_list),              'Board', "Board from List");
isa-ok(Board.new(Bag.new($cube_list)),     'Board', "Board from Bag");
isa-ok(Board.new(Bag.new($cube_list).kxxv),'Board', "Board from Seq");
isa-ok(Board.new(BagHash.new($cube_list)), 'Board', "Board from BagHash");
       
my Board $B .= new($cube_list.join(' '));
isa-ok($B,'Board',"Board from string with spaces");

lives-ok({ put $B.display },"Display a board -- check for space removal");
  
ok $B.unused.Bag == $cube_list.comb(/\S/).Bag, "initial unused";

ok $B.required  == qw< >,   "initial required";
ok $B.permitted == qw< >,   "initial permitted";
ok $B.forbidden == qw< >,   "initial forbidden";

ok $B.available == $B.unused, "initial available";

is $B.goal_options.sort(+*), [ 1,3,12,13,21,22,23,31,32,
			   122,123,132,212,213,221,
			   223,231,232,312,321,322 ].sort(+*), "initial goals";

$B.move_to_required('-');  

lives-ok( { $B.move_to_forbidden('3').move_to_permitted('+') }, "Chained moves" );

ok $B.unused    == qw< 1 2 2 >, "initial unused";
ok $B.required  == [ '-' ],     "initial required";
ok $B.permitted == [ '+' ],     "initial permitted";
ok $B.forbidden == [ '3' ],     "initial forbidden";
ok $B.available.sort == [ |$B.unused, |$B.required, |$B.permitted ].sort,  "initial available";

ok $B.goal_options == ( 1,12,21,22,122,212,221 ), "initial goals";

$B=Board.new(qw{ 0 0 0 0 2 2 3 3 3 4 5 7 7 8 8 * + + + - - / / @ @ ^ 8 3 + 8 - - / / ^ * 2 5 > }.join(''));
$B.move_to_permitted($_) for qw{ 8 3 + };
$B.move_to_required($_)  for qw{ 8 - - ^ * 2 5 };

lives-ok({ put $B.display },"Display a larger board");

$B.clear_solutions;
is $B.solution_list, Empty, "Empty solution list";
dies-ok( { $B.calculate_solutions(5) }, "Attempt to Calculate Solutions prior to setting goal should fail." );

$B.move_to_goal("20");
is( $B.goal, 20, "Goal is set for this board" );

lives-ok( { $B.calculate_solutions(5) }, "Can calculate once goal has been set." );
is $B.solution_list, ().list, "Empty solution list (still)";

lives-ok( { $B.calculate_solutions(9) }, "Calculate with more cubes" );

my @rpn_list=$B.solution_list;
for @rpn_list { is( $_.Numeric, $B.goal, "$_ from solution list evals to goal" ) }

ok( +@rpn_list == +@[filter_solutions_usable(  @rpn_list.map( *.Str ),$B.available.Bag)], "Every solution passed usable filter"   );
ok( +@rpn_list == +@[filter_solutions_required(@rpn_list.map( *.Str), $B.required.Bag )], "Every solution passed required filter" );


done-testing;
